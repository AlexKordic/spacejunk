<script>
// $(function(){
// iterate through each satellite creating it's own projection with the #{norad_id}path, set the rotation
// based on the revolutions per day and set the angle by the right ascension. No need for specific pathing
// as long as you can calculate the starting position along it's own equator. Completely eliminates the
// need to make LineStrings with specific coordinates. You can then give a length of a line at a right
// angle along it's own equator based on the speed of rotation, and give it a tail with a linear gradient.

// eventual data format:
// satellites = {
//   "topoObject":makeSatelliteObject(),          //  topoJSON formatted satellite point. Need to add longitude start
//   "satPath":satPath,                           //  Can add to satellite object to avoid making multiple arrays
//   "satProjection":satProjection,               //  Same as satPath
//   "adjustedRAAN": aR,
//   "projectionOffset": [λ,φ],                   //  Used for satellite rotation timer
//   "rotationVelocity":rotationVelocity          //  Longitudinal rotation speed, based on rotations per day
// }



var satellites = <%= @satellites.to_json.html_safe %>

// satellites = [satellites[0], satellites[1], satellites[2], satellites[3]]
// satellites = [satellites[7]]

satellites.forEach(function(d) {
  d.adjustedRAAN = getSiderealAscension(d);
  d.projectionOffset = getOffset(d)
  console.log(d.projectionOffset)
})


var width = $(window).width(),
    height = $(window).height(),
    pi = Math.PI,
    t0 = Date.now(),
    globeScale = (height)/4,  //
    satScale = (height)/2.9,  // needs to be edited for accurate distance.
    scaleRatio = globeScale/satScale,
    starScale = height,
    centerH = height/2,
    centerW = width/2,
    satClip = 90 + radToDeg(Math.acos(scaleRatio)); // auto adjust clip angle for satellites revolving around globe

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);


////////// GLOBE PROJECTION //////////////
var projection = d3.geo.orthographic()
    .scale(globeScale)
    .translate([centerW, centerH])
    .rotate([0,0,0])
    .clipAngle(90);

var path = d3.geo.path()
    .projection(projection);


/////// SATELLITE PROJECTION ////////////
// var satProjection = d3.geo.orthographic()
//     .scale(satScale)
//     .translate([centerW,centerH])
//     .clipAngle(satClip);

// var satPath = d3.geo.path()
//     .projection(satProjection)
//     .pointRadius(3);

  var satObjects = []
  satellites.forEach(function(d) {
    d.topoObject = makeSatelliteObject()
    satObjects.push(makeSatelliteObject())
    // satObjects.push(getArcs(d.inclination, d.right_asc))

    /////
    d.velocity = Math.random()*45
  });

///////

satProjections = []
satPaths = [];
satellites.forEach(function(d) {
  var satProjection = d3.geo.orthographic()
    .scale(satScale)
    .translate([centerW,centerH])
    // .rotate([d.projectionOffset[0], d.projectionOffset[1], d.inclination]) // needs to be rotated along the haversine line
    .clipAngle(satClip);

var satPath = d3.geo.path()
    .projection(satProjection);

    d.satPath = satPath;
    d.satProjection = satProjection;
  satPaths.push(satPath);
  satProjections.push(satProjection);
})


//////

var rotationVelocity = [30, 0]


//////////// STAR BACKGROUND //////////////
var starProjection = d3.geo.azimuthalEquidistant()
    .scale(height)
    .translate([width/2,height/2])

var starPath = d3.geo.path()
    .projection(starProjection)
    .pointRadius(Math.random() + 1)


///////////// ROTATION /////////////
// x-rotation
var λ = d3.scale.linear()
    .domain([0, width])
    .range([-180, 180]);

// y-rotation
// var φ = d3.scale.linear()
//     .domain([0, height])
//     .range([90, -90]);


// svg.on("mousemove", function() {
//   var p = d3.mouse(this);

//   starProjection.rotate([-λ(p[0]), 0]);
//   // satProjection.rotate([λ(p[0]), 0]);  // φ(p[1]) - for y-rotation
//   projection.rotate([λ(p[0]), 0, 23]);

//   svg.selectAll(".star").attr("d", starPath);
//   svg.selectAll(".globe").attr("d", path);
//   // svg.selectAll(".satellite").attr("d", satPath);
//   // svg.selectAll(".revolution").attr("d", satPath);
// });


////////////// STAR CREATION ////////////////
var starList = createStars(800);

var stars = svg.append("g")
        .attr("id", "stars")
    .selectAll("g")
    .data(starList)
    .enter()
    .append("path")
        .attr("class", "star")
        .attr("d", function(d){ return starPath(d); })
        .attr("opacity", function(d){ return randOpacity(.35, 1) });


  ////////////// TOPO FEATURES /////////////////

queue()
    .defer(d3.json, "world.json")
    .await(ready);

  function ready(error, world){

    var ocean = svg.append("path")
        .datum(topojson.feature(world, world.objects.ocean))
        .attr("class", "globe")
        .attr("id", "ocean")
        .attr("d", path);

    var land = svg.append("path")
        .datum(topojson.feature(world, world.objects.land))
        .attr("class", "globe")
        .attr("id", "land")
        .attr("d", path);

    var satElements = svg.selectAll("path.satellite")
        .data(satObjects)
        .enter()
        .append("path")
        .attr("class", "satellite")
        .attr("id", function(d, i) { return satellites[i].norad_id; })
        // .attr("xlink:href", "http://www.satview.org/imagens/satelite_icone_2.gif")

    d3.timer(function() {
      var t = (Date.now()-t0)/1000;
      // projection.rotate([0 + rotationVelocity[0]*t, 0, 0]);
      // ocean.attr("d", path);
      // land.attr("d", path);

      satProjections.forEach(function(d,i) {
        d.rotate([satellites[i].projectionOffset[1] + rotationVelocity[0]*t, satellites[i].projectionOffset[0], satellites[i].inclination])
        d3.select($("#"+satellites[i].norad_id)[0]).attr("d", function(d) {
          return satPaths[i](d)
        });
      });
      // satellites.forEach(function(d) {
      //   // console.log(d)
      //   (d.satProjection).rotate([d.right_asc + rotationVelocity[0]*t, 0, d.inclination]);
      //   d.topoObject
      //   d.satPath(d.topoObject);
      // });
    });
};









  ////////////////////////////// potential gradient //////////////////////

// var gradient = svg.append("svg:defs")
//   .append("svg:radialGradient")
//   .attr("id", "atmosphere-gradient")
//   .attr()

// EARTH BACKGROUND FOR POTENTIAL ATMOSPHERE //
// var backgroundCircle = svg.append("svg:circle")
//     .attr('cx', centerW)
//     .attr('cy', centerH)
//     .attr('r', globeScale)
//     .attr('class', 'atmosphere');
// });
</script>
