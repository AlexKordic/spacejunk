<script>

// iterate through each satellite creating it's own projection with the #{norad_id}path, set the rotation
// based on the revolutions per day and set the angle by the right ascension. No need for specific pathing
// as long as you can calculate the starting position along it's own equator. completely eliminates the
// need to make LineStrings with specific coordinates. You can then give a length of a line at a right
// angle along it's own equator based on the speed of rotation, and give it a tail with a linear gradient.


var satellites = <%= @satellites.to_json.html_safe %>

var width = $(window).width(),
    height = $(window).height(),
    pi = Math.PI,
    globeScale = (height)/4,
    satScale = (height)/2.9,
    scaleRatio = globeScale/satScale,
    starScale = height,
    centerH = height/2,
    centerW = width/2,
    satClip = 90 + radToDeg(Math.acos(scaleRatio)); // auto adjust clip angle for satellites revolving around globe

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);


////////// GLOBE PROJECTION //////////////
var projection = d3.geo.orthographic()
    .scale(globeScale)
    .translate([centerW, centerH])
    .clipAngle(90);

var path = d3.geo.path()
    .projection(projection);


/////// SATELLITE PROJECTION ////////////
var satProjection = d3.geo.orthographic()
    .scale(satScale)
    .translate([centerW,centerH])
    .clipAngle(satClip);

var satPath = d3.geo.path()
    .projection(satProjection)
    .pointRadius(3);

  var satObjects = []
  satellites.forEach(function(d) {
    satObjects.push(getArcs(d.inclination, d.right_asc))
  });

//////////// STAR BACKGROUND //////////////
var starProjection = d3.geo.azimuthalEquidistant()
    .scale(height)
    .translate([width/2,height/2])

var starPath = d3.geo.path()
    .projection(starProjection)
    .pointRadius(Math.random() + 1)


///////////// ROTATION /////////////
// x-rotation
var λ = d3.scale.linear()
    .domain([0, width])
    .range([-180, 180]);

// y-rotation
// var φ = d3.scale.linear()
//     .domain([0, height])
//     .range([90, -90]);

svg.on("mousemove", function() {
  var p = d3.mouse(this);

  starProjection.rotate([-λ(p[0]), 0]);
  // satProjection.rotate([λ(p[0]), 0]);  // φ(p[1]) - for y-rotation
  projection.rotate([λ(p[0]), 0]);

  svg.selectAll(".star").attr("d", starPath);
  svg.selectAll(".globe").attr("d", path);
  // svg.selectAll(".satellite").attr("d", satPath);
  // svg.selectAll(".revolution").attr("d", satPath);
});


////////////// STAR CREATION ////////////////
var starList = createStars(800);

var stars = svg.append("g")
        .attr("id", "stars")
    .selectAll("g")
    .data(starList)
    .enter()
    .append("path")
        .attr("class", "star")
        .attr("d", function(d){ return starPath(d); })
        .attr("opacity", function(d){ return Math.random() });


  ////////////// TOPO FEATURES /////////////////

queue()
    .defer(d3.json, "world.json")
    .await(ready);

  function ready(error, world){

    svg.append("path")
        .datum(topojson.feature(world, world.objects.ocean))
        .attr("class", "globe")
        .attr("id", "ocean")
        .attr("d", path);

    svg.append("path")
        .datum(topojson.feature(world, world.objects.land))
        .attr("class", "globe")
        .attr("id", "land")
        .attr("d", path);

      svg.selectAll("path.revolution")
        .data(satObjects)
        .enter()
        .append("path")
        .attr("class", "revolution")
        .attr("id", function(d, i) { return d.norad_id; })
        .attr("d", satPath);

};











  ////////////////////////////// potential gradient //////////////////////

// var gradient = svg.append("svg:defs")
//   .append("svg:radialGradient")
//   .attr("id", "atmosphere-gradient")
//   .attr()

// EARTH BACKGROUND FOR POTENTIAL ATMOSPHERE //
// var backgroundCircle = svg.append("svg:circle")
//     .attr('cx', centerW)
//     .attr('cy', centerH)
//     .attr('r', globeScale)
//     .attr('class', 'atmosphere');

</script>
