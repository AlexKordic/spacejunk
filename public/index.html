<html>
<head>
  <title>Satellites</title>
  <link rel="stylesheet" href="stylesheets/styles.css">
  <script src="vendor/three.min.js"></script>
  <script src="vendor/jquery.js"></script>
  <script src="javascripts/scripts.js"></script>
  <script src="javascripts/sgp.js"></script>
  <script src="javascripts/OrbitControls.js"></script>
</head>
<body>

<script>

  // init
  var HEIGHT   = window.innerHeight,
      WIDTH    = window.innerWidth;

  var earthRadius = 6371,
      timeStart   = Date.now() / 1000,
      speedFactor = 4;                  // 24: 1day == 1min

  var renderer, scene, camera, geometry, material, earthMesh,
      light, controls;

  var satellites, satTarget;

  var tracking = false,
      center = new THREE.Vector3();

  var priorTime = timeStart,
      elapsed = 0;

$.getJSON("/satdata", function(data){

  satellites = data;
  satellites.forEach(function(sat){
    sat.minSinceEpoch = (timeStart - JulianToUnix(sat.epoch_date)/1000)/60
  });
  satTarget = satellites[0];

  function init() {
    renderer = new THREE.WebGLRenderer();
    renderer.setSize(WIDTH, HEIGHT);
    renderer.shadowMapEnabled = true;
    document.body.appendChild(renderer.domElement);

    scene  = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(45, WIDTH/HEIGHT, 1, 500000);
    camera.position.z = earthRadius * 3;
    scene.add(camera)

    // create earth
    geometry                = new THREE.SphereGeometry(earthRadius, 50, 50);
    material                = new THREE.MeshPhongMaterial();
    material.map            = THREE.ImageUtils.loadTexture("images/earthmap1k.jpg");
    material.bumpMap        = THREE.ImageUtils.loadTexture("images/earthbump1k.jpg");
    material.bumpScale      = earthRadius / 10;
    material.specularMap    = THREE.ImageUtils.loadTexture("images/earthspec1k.jpg");
    material.specular       = new THREE.Color("grey");
    earthMesh               = new THREE.Mesh(geometry, material);

    earthMesh.rotateY(-Math.PI/2)     // aligns to [0,0]
    scene.add(earthMesh)

    // light
    scene.add(new THREE.AmbientLight(0x888888));
    light = new THREE.DirectionalLight(0xcccccc, .6);
    light.position.set(-1000000,432738.64224742586,0);         // Creates 23.4 degree angle of axial tilt
    scene.add(light);

    // satellites
    satSphere = new THREE.SphereGeometry(30);
    satellites.forEach(function(sat) {
      sat.satMesh   = new THREE.Mesh(satSphere, new THREE.MeshBasicMaterial({ color: 0x87c540 }));
      scene.add(sat.satMesh);
    })

    // mouse controls
    controls = new THREE.OrbitControls(camera, renderer.domElement);

    // resize
    window.addEventListener('resize', function() {
      var WIDTH = window.innerWidth,
          HEIGHT = window.innerHeight;

      renderer.setSize(WIDTH, HEIGHT);
      camera.aspect = WIDTH / HEIGHT;
      camera.updateProjectionMatrix();
    });
  }

  function render() {
    timeNow = Date.now() / 1000;
    delta   = timeNow - priorTime;
    satellites.forEach(function(sat){
      var location = sgp(sat, sat.minSinceEpoch + elapsed + delta*speedFactor);
      sat.satMesh.position.x = location.X;
      sat.satMesh.position.y = location.Y;
      sat.satMesh.position.z = location.Z;
    });

    if (tracking == true) {
      var camLocation = sgp(satTarget, satTarget.minSinceEpoch + elapsed + delta*speedFactor);
      var trackPosition = new THREE.Vector3(camLocation.X - 600*camLocation.XDOT,camLocation.Y - 600*camLocation.YDOT,camLocation.Z - 600*camLocation.ZDOT);
      var trackTarget = new THREE.Vector3(camLocation.X + 1000*camLocation.XDOT,camLocation.Y + 1000*camLocation.YDOT,camLocation.Z + 1000*camLocation.ZDOT);
      var latitude = XYZtoLLA(camLocation.X,camLocation.Y,camLocation.Z).latitude;

      // aligns the camera with the earth underneath
      camera.up = new THREE.Vector3(10*camLocation.X, 10*camLocation.Y, 10*camLocation.Z);
      camera.lookAt(trackTarget);
      camera.position.copy(trackPosition);
    } else {
      camera.up = new THREE.Vector3(0,1,0)
      camera.lookAt(center);
    }

    earthMesh.rotateY(speedFactor * 2 * Math.PI * delta / 1440 );        // 1 rpm = 2 * Math.PI / 60 * delta
    renderer.render(scene, camera);
    elapsed  = elapsed + delta*speedFactor;
    priorTime = timeNow;
  }


  function animate() {
    requestAnimationFrame(animate);
    render();
    controls.update();
  }


  init();
  animate();
});
</script>
</body>
</html>
